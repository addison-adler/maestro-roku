import "pkg:/source/core/Utils.bs"
import "pkg:/source/core/BaseClass.bs"

namespace mg
  class MapLayer extends mc.BaseClass
    mapSize = [0, 0]
    private group as mc.types.node
    private rowLength = 0
    private numberOfRows = 0

    private isPoolInitialized = false
    private freePosters = []
    private usedPosters = {}

    private screenTileWidth = 128
    private screenTileHeight = 128
    private screenHeight = 1080
    private screenWidth = 1920
    private tilesPerVisibleRow = int(m.screenWidth / m.screenTileWidth)
    private tilesPerVisibleColumn = int(m.screenHeight / m.screenTileHeight)
    private mapX = -1
    private mapY = -1
    private tileData = []
    private prefix = "t"


    private startX = -1
    private startY = -1
    private endX = -1
    private endY = -1

    function new(group as mc.types.node, numberToCache as integer, prefix as string)
      super("MapLayer")
      m.group = group
      m.prefix = prefix
      m.initializePool(numberToCache)
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function renderTilesAtCurrentPosition()
      ' m.log.info("Rendering tiles at current position")

      ' Clear previously rendered platforms (assuming you have a method to reset or clear posters)
      for each id in m.usedPosters
        poster = m.usedPosters[id]
        if poster <> invalid
          m.releasePoster(poster)
          poster.visible = false ' Make sure to hide the poster
        end if
      end for
      m.usedPosters = {} ' Reset the dictionary after releasing posters

      ' m.log.info("Rendering map at position", m.mapX, m.mapY, m.tilesPerVisibleColumn, "x", m.tilesPerVisibleRow)

      ' Iterate over all tiles starting from the current map position
      for rowIndex = m.mapY to m.mapY + m.tilesPerVisibleColumn
        for colIndex = m.mapX to m.mapX + m.tilesPerVisibleRow
          tileIndex = rowIndex * m.rowLength + colIndex ' Use m.rowLength here
          if tileIndex >= 0 and tileIndex < m.tileData.count()
            tileValue = m.tileData[tileIndex]
            ' ? " TILE INDEX " tileIndex " VALUE " tileValue

            if m.isRenderedTile(tileValue)
              ' ? " RENDERING TILE AT " rowIndex ", " colIndex " WITH VALUE " tileValue
              m.renderTile(tileIndex, rowIndex, colIndex, tileValue)
            end if
          end if
        end for
      end for
    end function

    ' function getPlatformTilePoster(target as mc.types.node, ySpeed as float)
    '   return m.getTilePoster(target, ySpeed)
    ' end function

    function getPlatformTilePoster(target as mc.types.node, ySpeed as float)
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      targetTranslation = target.translation
      targetTranslation = [targetTranslation[0] + feetTranslation[0], targetTranslation[1] + feetTranslation[1] + feetCollider.height] ' Adjust to check platform tops

      currentRow = int(targetTranslation[1] / m.screenTileHeight)
      currentCol = int(targetTranslation[0] / m.screenTileWidth)

      ' Check directly under the player's feet
      tileIndex = currentRow * m.rowLength + currentCol
      if tileIndex >= 0 and tileIndex < m.tileData.count()
        tileValue = m.tileData[tileIndex]
        if m.isCollidableTile(tileValue)
          return m.usedPosters["t_" + tileIndex.toStr()] ' Ensure this refers to a valid platform poster or platform data
        end if
      end if

      return invalid
    end function


    function updateCameraView(startX as integer, startY as integer, endX as integer, endY as integer)
      m.startX = int(startX)
      m.startY = int(startY)
      m.endX = int(endX)
      m.endY = int(endY)
      ' m.mapX = m.startX
      ' m.mapY = m.startY
      m.update()
    end function

    function update(event as mc.types.assocarray) as void
      ' Release old tiles
      for rowIndex = event.oldStartY to event.oldEndY
        for colIndex = event.oldStartX to event.oldEndX
          if rowIndex < event.newStartY or rowIndex > event.newEndY or colIndex < event.newStartX or colIndex > event.newEndX
            tileIndex = rowIndex * m.rowLength + colIndex
            if m.usedPosters.doesExist(m.prefix + tileIndex.toStr())
              m.releasePoster(m.usedPosters[m.prefix + tileIndex.toStr()])
              m.usedPosters.delete(m.prefix + tileIndex.toStr())
            end if
          end if
        end for
      end for

      ' Render new tiles
      for rowIndex = event.newStartY to event.newEndY
        for colIndex = event.newStartX to event.newEndX
          if rowIndex < event.oldStartY or rowIndex > event.oldEndY or colIndex < event.oldStartX or colIndex > event.oldEndX
            tileIndex = rowIndex * m.rowLength + colIndex
            if tileIndex >= 0 and tileIndex < m.tileData.count()
              tileValue = m.tileData[tileIndex]
              if m.isRenderedTile(tileValue)
                m.renderTile(tileIndex, rowIndex, colIndex, tileValue)
              end if
            end if
          end if
        end for
      end for
    end function

    ' function getSideCollision(target as object, xSpeed as float) as object
    '   'FIXME - update to use tile data
    '   ' feetCollider = target.feetCollider
    '   ' feetTranslation = feetCollider.translation
    '   ' characterTranslation = target.translation
    '   ' characterPosition = [characterTranslation[0] + feetTranslation[0], characterTranslation[1] + feetTranslation[1]]

    '   ' currentRow = Int(characterPosition[1] / m.screenTileHeight)
    '   ' searchRows = [currentRow] ' Consider current row for lateral collision

    '   ' for each rowIndex in searchRows
    '   '   if rowIndex < m.platformsByRow.count() and rowIndex >= 0
    '   '     for each platform in m.platformsByRow[rowIndex]
    '   '       if platform <> invalid
    '   '         platformTranslation = platform.translation
    '   '         platformLeft = platformTranslation[0]
    '   '         platformRight = platformTranslation[0] + platform.size[0]
    '   '         characterLeft = characterPosition[0]
    '   '         characterRight = characterPosition[0] + feetCollider.width

    '   '         ' Moving right and approaching the left boundary of a platform
    '   '         if direction = 1 and characterRight > platformLeft and characterLeft < platformRight
    '   '           ' Allow passing through if moving outwards from within a platform
    '   '           if characterLeft < platformLeft
    '   '             return platform ' Collision on the right
    '   '           end if

    '   '           ' Moving left and approaching the right boundary of a platform
    '   '         else if direction = -1 and characterLeft < platformRight and characterRight > platformLeft
    '   '           ' Allow passing through if moving outwards from within a platform
    '   '           if characterRight > platformRight
    '   '             return platform ' Collision on the left
    '   '           end if
    '   '         end if
    '   '       end if
    '   '     end for
    '   '   end if
    '   ' end for

    '   return invalid ' No collision detected, allowing free movement
    ' end function
    function getSideCollision(target as object, xSpeed as float, isOnGround as boolean) as object
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      targetTranslation = target.translation
      characterPosition = [targetTranslation[0] + feetTranslation[0], targetTranslation[1] + feetTranslation[1]]

      currentRow = Int(characterPosition[1] / m.screenTileHeight)
      currentCol = Int(characterPosition[0] / m.screenTileWidth)

      ' Calculate potential tiles based on movement direction
      direction = xSpeed > 0 ? 1 : -1
      checkColumns = [currentCol, currentCol + direction] ' Check current and next/previous column based on direction

      for each col in checkColumns
        tileIndex = currentRow * m.rowLength + col
        if tileIndex >= 0 and tileIndex < m.tileData.count()
          tileValue = m.tileData[tileIndex]
          if m.isSideCollidableTile(tileValue) or isOnGround and m.isCollidableTile(tileValue)
            ' Verify horizontal alignment to ensure collision
            platformLeft = col * m.screenTileWidth
            platformRight = platformLeft + m.screenTileWidth
            characterLeft = characterPosition[0]
            characterRight = characterPosition[0] + feetCollider.width

            if (direction = 1 and characterRight > platformLeft and characterLeft < platformRight) or (direction = -1 and characterLeft < platformRight and characterRight > platformLeft)
              ' Found valid collision, return the associated poster or platform data
              if m.usedPosters.doesExist(m.prefix + tileIndex.toStr())
                return m.usedPosters[m.prefix + tileIndex.toStr()]
              end if
            end if
          end if
        end if
      end for

      return invalid ' No collision detected
    end function


    function reset()
      m.renderTilesAtCurrentPosition()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    private function getTilePoster(target as mc.types.node, ySpeed as float)
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      targetTranslation = target.translation
      targetTranslation = [targetTranslation[0] + feetTranslation[0], targetTranslation[1] + feetTranslation[1]]

      currentCol = int(targetTranslation[0] / m.screenTileWidth)
      overlapThreshold = 50 ' pixels of overlap required to check adjacent columns
      currentColPixelOffset = targetTranslation[0] mod m.screenTileWidth

      ' Check the tile directly below the player first
      tilePoster = m.getTilePosterBelowPlayer(targetTranslation, feetCollider, ySpeed, currentCol)

      ' Check if player overlaps the next column by at least 50 pixels
      if tilePoster = invalid and (currentColPixelOffset + feetCollider.width) > m.screenTileWidth + (overlapThreshold / 4)
        tilePoster = m.getTilePosterBelowPlayer(targetTranslation, feetCollider, ySpeed, currentCol + 1)
      end if

      ' Check if player overlaps the previous column by at least 50 pixels
      if tilePoster = invalid and currentColPixelOffset < overlapThreshold
        tilePoster = m.getTilePosterBelowPlayer(targetTranslation, feetCollider, ySpeed, currentCol - 1)
      end if

      return tilePoster
    end function

    private function getTilePosterBelowPlayer(targetTranslation as mc.types.array, feetCollider as mc.types.node, ySpeed as float, currentCol as integer)

      currentRow = int(targetTranslation[1] / m.screenTileHeight)

      ' Calculate the number of rows to check based on the fall speed.
      fallSpeedRows = abs(ySpeed) / m.screenTileHeight
      rowsToCheck = mc.clamp(int(fallSpeedRows), 2, 5)

      for rowIndex = currentRow to currentRow + rowsToCheck
        tileIndex = (rowIndex * m.mapSize[0]) + currentCol
        if tileIndex >= 0 and tileIndex < m.tileData.count()
          tileValue = m.tileData[tileIndex]
          if m.isCollidableTile(tileValue)
            ' Verify vertical alignment
            platformTop = rowIndex * m.screenTileHeight
            playerBottom = targetTranslation[1] + feetCollider.height
            if playerBottom >= platformTop and playerBottom < platformTop + m.screenTileHeight
              return m.usedPosters[m.prefix + tileIndex.toStr()]
            end if
          end if
        end if
      end for

      return invalid
    end function


    private sideTiles = {
      "7": true
      "9": true
      "16": true
      "20": true
      "20": true
      "13": true
    }

    private platformTiles = {
      "2": true
      "3": true
      "4": true
      "11": true
      "15": true
      "17": true
      "17": true
      "18": true
      "19": true
    }
    private function isCollidableTile(tileValue as integer)
      return m.platformTiles[tileValue.toStr()] = true
    end function

    private function isSideCollidableTile(tileValue as integer)
      return m.sideTiles[tileValue.toStr()] = true
    end function

    private function isRenderedTile(tileValue as integer)
      return tileValue <> 0 and tileValue <> 5 and tileValue <> 10 and tileValue <> 6
    end function

    protected function initializePool(numberToCache as integer)
      for i = 0 to numberToCache
        m.freePosters.push(mc.createSGNode({
          "_type": "mv_Poster"
          "id": m.prefix + i.toStr()
          tileId: 0
        }, m.group))
      end for
      m.usedPosters = {}
    end function

    private function releasePoster(poster as mc.types.node) as void
      if poster <> invalid
        ' ? " RELEASING POSTER " poster.id
        poster.visible = false
        m.usedPosters.delete(poster.id)
        m.freePosters.push(poster)
      end if
    end function

    private function getPosterForTile(tileIndex as integer) as mc.types.node
      poster = m.freePosters.pop()
      if poster <> invalid
        poster.id = m.prefix + tileIndex.toStr()
        poster.visible = true
        m.usedPosters[poster.id] = poster
      else
        m.log.warn("No more posters!")
      end if
      return poster
    end function

    protected function parseData(layerData as mc.types.assocarray)
      m.tileData = layerData.data
      m.rowLength = layerData.width
      m.numberOfRows = layerData.height
      m.mapSize = [layerData.width, layerData.height]
    end function

    protected function renderTile(tileIndex as integer, rowIndex as integer, colIndex as integer, tileValue as integer)
      if m.usedPosters[m.prefix + tileIndex.toStr()] = invalid
        poster = m.getPosterForTile(tileIndex)
        yPos = rowIndex * m.screenTileHeight
        poster.translation = [colIndex * m.screenTileWidth, yPos]
        poster.uri = `pkg:/images/tiles/${tileValue}.png`
      else
        'already rendered
      end if
    end function

  end class
end namespace
