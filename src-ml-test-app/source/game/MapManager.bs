import "pkg:/source/core/Utils.bs"
import "pkg:/source/core/BaseClass.bs"
import "pkg:/source/game/platforms/Platform.bs"

namespace mg
  @node("MapManager", "Group")
  class MapManager extends mc.BaseClass
    mapSize = [0, 0]
    private platforms = []
    private levelGroup as mc.types.node
    private screenTileWidth = 128
    private screenTileHeight = 128
    private platformsByRow = []
    private itemsByRow = []
    private playerStartPosition = [0, 0]

    'levels have different layers
    private backgroundGroup as mc.types.node
    private platformsGroup as mc.types.node
    private itemsGroup as mc.types.node
    private foregroundGroup as mc.types.node
    private isPoolInitialized = false
    private cachedTiles = []

    private screenHeight = 1080
    private screenWidth = 1920
    private tilesPerVisibleRow = int(m.screenWidth / m.screenTileWidth)
    private tilesPerVisibleColumn = int(m.screenHeight / m.screenTileHeight)
    private mapX = -1
    private mapY = -1

    function new()
      super("MapManager")
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function loadMap(levelGroup as mc.types.node, file as string)
      m.levelGroup = levelGroup
      text = readAsciiFile(file)
      m.prepareLevelGroup()
      if not m.isPoolInitialized
        m.initializePool()
      end if
      json = text = invalid ? invalid : parseJson(text)
      m.parseTMX(json)
      m.levelGroup.translation = [0, 0]
      m.renderTilesAtCurrentPosition()
    end function

    function renderTilesAtCurrentPosition()
      ' Release all currently rendered platforms
      for each id in m.renderedPlatforms
        platform = m.renderedPlatforms[id]
        if platform <> invalid
          m.releasePooledPlatform(platform)
          platform.visible = false ' Ensure the platform is also set to invisible when released
        end if
      end for
      m.renderedPlatforms.clear() ' Clear the list after releasing

      ' Calculate the actual number of visible tiles based on screen size and tile size
      visibleRows = m.tilesPerVisibleRow
      visibleColumns = m.tilesPerVisibleColumn

      m.log.info("Rendering map at position", m.mapX, m.mapY, visibleColumns, "x", visibleRows)

      ' Iterate over all tiles starting from the current map position
      for rowIndex = m.mapY to m.mapY + visibleRows
        if rowIndex < m.platformsByRow.count() and rowIndex >= 0
          row = m.platformsByRow[rowIndex]
          for colIndex = m.mapX to m.mapX + visibleColumns
            if colIndex < row.count() and colIndex >= 0
              platform = row[colIndex]
              if platform <> invalid
                ? " TILE " colIndex ", " rowIndex " " ;
                m.assignViewToPlatform(platform)
              end if
            end if
          end for
        end if
      end for
    end function


    function getPlatformPoster(target as mc.types.node, ySpeed as float)
      platform = m.getPlatform(target, ySpeed)
      if platform <> invalid
        return platform.poster
      end if
      return invalid
    end function

    function getPlatform(target as mc.types.node, ySpeed as float)
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      targetTranslation = target.translation
      targetTranslation = [targetTranslation[0] + feetTranslation[0], targetTranslation[1] + feetTranslation[1]]

      currentRow = int(targetTranslation[1] / m.screenTileHeight)
      currentCol = int(targetTranslation[0] / m.screenTileWidth)

      ' Calculate the number of rows to check based on the fall speed.
      ' This accounts for the possibility of falling through multiple rows in a single frame.
      fallSpeedRows = abs(ySpeed) / m.screenTileHeight
      rowsToCheck = mc.clamp(int(fallSpeedRows), 2, 5)
      rowsToCheck = 1

      ' Check for collision in a range from the current row to the number of rows the player could have fallen through.
      for rowIndex = currentRow to currentRow + rowsToCheck
        if rowIndex < m.platformsByRow.count() and rowIndex >= 0
          for each platform in m.platformsByRow[rowIndex]
            if platform <> invalid
              'limit the colliders we look at
              platformStartCol = platform.startIndex - 1
              platformEndCol = platformStartCol + platform.length

              ' Determine if the target's current column intersects with the platform's column range
              if currentCol >= platformStartCol and currentCol <= platformEndCol
                collisionType = platform.getPlatformCollision(feetCollider)
                if collisionType = mg.PlatformCollision.OnPlatform
                  return platform
                end if
              end if
            end if
          end for
        end if
      end for

      return invalid
    end function

    private startX = -1
    private startY = -1
    private endX = -1
    private endY = -1

    function updateCameraView(startX as integer, startY as integer, endX as integer, endY as integer)
      m.startX = int(startX)
      m.startY = int(startY)
      m.endX = int(endX)
      m.endY = int(endY)
      ' m.mapX = m.startX
      ' m.mapY = m.startY
      m.update()
    end function

    function update() as void
      ' Retrieve current translation of levelGroup to determine which part of the map is visible
      newMapX = m.startX
      newMapY = m.startY

      ' Check if the map position has changed since the last update
      if newMapX = m.mapX and newMapY = m.mapY
        return ' If the position hasn't changed, no need to update
      end if

      ' Calculate delta changes
      deltaX = newMapX - m.mapX
      deltaY = newMapY - m.mapY

      ' ? " RENDER WITH DELTA " deltaX " , " deltaY " from " m.mapX " : " m.mapY " to " newMapX ", " newMapY
      ' Update current map positions for the next check
      m.mapX = newMapX
      m.mapY = newMapY

      ' Calculate the bounds of the previously visible area
      oldStartX = m.mapX - deltaX
      oldStartY = m.mapY - deltaY
      oldEndX = oldStartX + (m.screenWidth / m.screenTileWidth)
      oldEndY = oldStartY + (m.screenHeight / m.screenTileHeight)

      ' Calculate the bounds of the new visible area
      newStartX = m.mapX
      newStartY = m.mapY
      newEndX = newStartX + (m.screenWidth / m.screenTileWidth)
      newEndY = newStartY + (m.screenHeight / m.screenTileHeight)

      if oldStartY < 0 or oldStartX < 0 or oldEndX >= m.mapSize[0] or oldEndY >= m.mapSize[1] or newStartY < 0 or newStartX < 0 or newEndX >= m.mapSize[0] or newEndY >= m.mapSize[1]
        return
      end if
      ' Release old tiles
      ' Only tiles that are not in the new visible area but were in the old visible area need to be released
      for rowIndex = oldStartY to oldEndY
        if rowIndex < newStartY or rowIndex > newEndY
          for colIndex = oldStartX to oldEndX
            if colIndex < newStartX or colIndex > newEndX
              platform = m.platformsByRow[rowIndex][colIndex]
              m.releasePooledPlatform(platform)
            end if
          end for
        end if
      end for

      ' Render new tiles
      ' Only tiles that are in the new visible area but were not in the old visible area need to be rendered
      for rowIndex = newStartY to newEndY
        for colIndex = newStartX to newEndX
          if rowIndex < oldStartY or rowIndex > oldEndY or colIndex < oldStartX or colIndex > oldEndX
            platform = m.platformsByRow[rowIndex][colIndex]
            m.assignViewToPlatform(platform)
          end if
        end for
      end for

      ' ? " RENDERING: " m.mapX " " m.mapY
      ' ? " OLD ROWS: " oldStartY " to " oldEndY " NEW ROWS: " newStartY " to " newEndY
      ' ? " OLD COLUMNS: " oldStartX " to " oldEndX " NEW COLUMNS: " newStartX " to " newEndX
    end function


    function collectItems(target as mc.types.node)
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      targetTranslation = target.translation
      targetTranslation = [targetTranslation[0] + feetTranslation[0], targetTranslation[1] + feetTranslation[1]]

      currentRow = int(targetTranslation[1] / m.screenTileHeight)
      currentCol = int(targetTranslation[0] / m.screenTileWidth)
      currentColString = currentCol.toStr()
      ' Check for collision in the current row and possibly the row below.
      for rowIndex = currentRow - 1 to currentRow
        if rowIndex < m.itemsByRow.count() and rowIndex >= 0
          item = m.itemsByRow[rowIndex][currentColString]
          if item <> invalid and not item.isCollected and item.startIndex = currentCol
            if item.effect = "kill"
              target@.onHit(item)
            else
              item.visible = false
              item.isCollected = true
            end if
          end if
        end if
      end for

      return invalid
    end function

    function getSideCollision(target as object, direction as integer) as object
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      characterTranslation = target.translation
      characterPosition = [characterTranslation[0] + feetTranslation[0], characterTranslation[1] + feetTranslation[1]]

      currentRow = Int(characterPosition[1] / m.screenTileHeight)
      searchRows = [currentRow] ' Consider current row for lateral collision

      for each rowIndex in searchRows
        if rowIndex < m.platformsByRow.count() and rowIndex >= 0
          for each platform in m.platformsByRow[rowIndex]
            if platform <> invalid
              platformTranslation = platform.translation
              platformLeft = platformTranslation[0]
              platformRight = platformTranslation[0] + platform.size[0]
              characterLeft = characterPosition[0]
              characterRight = characterPosition[0] + feetCollider.width

              ' Moving right and approaching the left boundary of a platform
              if direction = 1 and characterRight > platformLeft and characterLeft < platformRight
                ' Allow passing through if moving outwards from within a platform
                if characterLeft < platformLeft
                  return platform ' Collision on the right
                end if

                ' Moving left and approaching the right boundary of a platform
              else if direction = -1 and characterLeft < platformRight and characterRight > platformLeft
                ' Allow passing through if moving outwards from within a platform
                if characterRight > platformRight
                  return platform ' Collision on the left
                end if
              end if
            end if
          end for
        end if
      end for

      return invalid ' No collision detected, allowing free movement
    end function

    function resetLevel()
      ? "resetting level"
      for each row in m.itemsByRow
        for each item in row.items()
          item.visible = true
          item.isCollected = false
        end for
      end for
      m.renderTilesAtCurrentPosition()
    end function

    function getPlayerStartPosition()
      return m.playerStartPosition
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function initializePool()
      for i = 0 to 200
        m.platforms.push(mc.createSGNode({
          "_type": "mv_Poster"
          "id": "platform" + i.toStr()
          isInUse: false
        }, m.platformsGroup))
      end for
    end function

    private function assignViewToPlatform(platform as mg.Platform) as void
      if platform = invalid
        ' m.log.error("Cant assign a view to invalid platform")
        return
      end if

      p = m.platforms.pop()
      if p <> invalid
        p.isInUse = true
        ' ? " RENDERING " platform.id " with poster " p.id
        m.renderedPlatforms[platform.id] = platform
        platform.setView(p)
      else
        m.log.error("ran out of platforms")
      end if
    end function

    private renderedPlatforms = {}
    private function releasePooledPlatform(platform as mg.Platform) as void
      if platform = invalid
        m.log.error("Cant assign a view to invalid platform")
        return
      end if
      poster = platform.poster
      if poster <> invalid
        ? " RELEASING POSTER " poster.id
        poster.isInUse = false
        poster.visible = false
        m.platforms.push(poster)
        m.renderedPlatforms.delete(platform.id)
      end if
    end function

    private function prepareLevelGroup()
      for each group in m.levelGroup.getChildren(-1, 0)
        group.removeChildren(group.getChildren(-1, 0))
      end for

      m.levelGroup.removeChildren(m.levelGroup.getChildren(-1, 0))
      m.backgroundGroup = mc.createSGNode("Group", m.levelGroup, "backgroundGroup")
      m.platformsGroup = mc.createSGNode("Group", m.levelGroup, "platformsGroup")
      m.itemsGroup = mc.createSGNode("Group", m.levelGroup, "itemsGroup")
      m.foregroundGroup = mc.createSGNode("Group", m.levelGroup, "foregroundGroup")
    end function

    private function parseTMX(tmxData as mc.types.assocarray)
      for each layerData in tmxData.layers
        if layerData.name = "foreground"
          m.parsePlatformLayer(layerData, m.foregroundGroup)
        else if layerData.name = "background"
          m.parsePlatformLayer(layerData, m.backgroundGroup)
        else if layerData.name = "platforms"
          m.parsePlatformLayer(layerData, m.platformsGroup)
        else if layerData.name = "items"
          m.parseItemLayer(layerData, m.itemsGroup)
        else
          ? "UNKNOWN LAYER! " layerData.name
        end if
      end for
    end function

    'TODO - we should have a finite amount of tiles.. and then reuse them as we scroll
    ' Define a function to parse TMX JSON and create platforms
    private function parsePlatformLayer(layerData as mc.types.assocarray, targetNode as mc.types.node)
      ' Loop through each layer (assuming single layer for simplicity)
      ' Assuming a single layer for simplicity, process its data
      rowData = layerData.data
      rowLength = layerData.width
      numberOfRows = layerData.height
      m.mapSize = [layerData.width * m.screenTileWidth, layerData.height * m.screenTileHeight]
      platformUri = ""

      ' Process each row
      for rowIndex = 0 to numberOfRows - 1
        rowStartIndex = rowIndex * rowLength
        rowEndIndex = (rowIndex + 1) * rowLength - 1
        startIndex = -1
        length = 0

        ' Process each tile in the row
        for tileIndex = rowStartIndex to rowEndIndex
          tileValue = rowData[tileIndex]
          if tileValue <> 0 and tileValue <> 5 and tileValue <> 10 and tileValue <> 6
            startIndex = tileIndex - rowStartIndex
            ? " MAKING A TILE " tileValue " id " startIndex
            platform = m.createPlatform(rowIndex, startIndex, 1, "p_" + str(startIndex))
            ' platform.visible = false
            platform.uri = `pkg:/images/tiles/${tileValue}.png`
          end if
        end for
      end for
    end function

    'TODO - we should have a finite amount of tiles.. and then reuse them as we scroll
    ' Define a function to parse TMX JSON and create platforms
    private function parseItemLayer(layerData as mc.types.assocarray, targetNode as mc.types.node)
      ' Loop through each layer (assuming single layer for simplicity)
      ' Assuming a single layer for simplicity, process its data
      rowData = layerData.data
      rowLength = layerData.width
      numberOfRows = layerData.height
      m.mapSize = [layerData.width * m.screenTileWidth, layerData.height * m.screenTileHeight]

      ' Process each row
      for rowIndex = 0 to numberOfRows - 1
        rowStartIndex = rowIndex * rowLength
        rowEndIndex = (rowIndex + 1) * rowLength - 1
        startIndex = -1

        ' Process each tile in the row
        for tileIndex = rowStartIndex to rowEndIndex
          tileValue = rowData[tileIndex]

          ' Check if tile is not empty and start index is not set
          if tileValue <> 1 and startIndex = -1
            if tileValue = 28
              ? "found player start position"
              m.setStartPosition(rowIndex, tileIndex - rowStartIndex)
              startIndex = -1
            else if tileValue = 23
              ? "COIN"
              m.createItem(rowIndex, tileIndex - rowStartIndex, "c_" + str(tileIndex), mg.GameItemType.Coin)
              startIndex = -1
            else if tileValue = 24
              ? "BAD GUY"
              m.createItem(rowIndex, tileIndex - rowStartIndex, "e1_" + str(tileIndex), mg.GameItemType.Enemy1)
              startIndex = -1
              if tileValue <> 0 and tileValue <> 5 and tileValue <> 10 and tileValue <> 6
                ? " UNKNOWN ITEM " tileValue
              end if
            end if
          end if
        end for
      end for
    end function

    private function createPlatform(rowIndex as integer, startIndex as integer, length as integer, id as string)
      yPos = rowIndex * m.screenTileHeight
      platform = new mg.Platform()
      platform.id = id
      platform.translation = [startIndex * m.screenTileWidth, yPos]
      platform.size = [length * m.screenTileWidth, m.screenTileHeight]
      platform.startIndex = startIndex
      platform.length = length
      platform.rowIndex = rowIndex
      platform.color = "#5A24B6"
      rows = m.platformsByRow[rowIndex]
      if rows = invalid
        dim rows[m.mapSize[0]]
        ' rows = []
        m.platformsByRow.push(rows)
      end if
      ' rows.push(platform)
      ? " SETTING TILE AT COL " startIndex " ROW " rowIndex
      rows[startIndex] = platform
      return platform
    end function

    private function setStartPosition(rowIndex as integer, colIndex as integer)
      yPos = rowIndex * m.screenTileHeight
      m.playerStartPosition = [colIndex * m.screenTileWidth, yPos - m.screenTileHeight + 5]
      ? " set player start pos to " m.playerStartPosition
    end function

    private function createItem(rowIndex as integer, colIndex as integer, id as string, itemType as mg.GameItemType)
      yPos = rowIndex * m.screenTileHeight
      item = mc.createSGNode({
        "_type": "GameItem"
        "id": id

        translation: [colIndex * m.screenTileWidth, yPos]
        size: [m.screenTileWidth, m.screenTileHeight]
        startIndex: colIndex
        length: 1
        effect: "kill"
        rowIndex: rowIndex
      }, m.itemsGroup)
      m.initializeGameItem(item, itemType)
      rows = m.itemsByRow[rowIndex]
      if rows = invalid
        rows = {}
        m.itemsByRow.push(rows)
      end if
      rows[colIndex.toStr()] = item
      return item
    end function

    private function initializeGameItem(item as mc.types.node, itemType as mg.GameItemType)
      if itemType = mg.GameItemType.coin
        item.uri = "pkg:/images/sprites/coin-tile.png"
        item.effect = mg.GameItemEffect.Coin
      else if itemType = mg.GameItemType.Enemy1
        item.uri = "pkg:/images/sprites/bad-guy.png"
        item.effect = mg.GameItemEffect.Kill
      else if itemType = mg.GameItemType.Enemy2
        item.uri = "pkg:/images/sprites/bad-guy.png"
        item.effect = mg.GameItemEffect.Kill
      else if itemType = mg.GameItemType.Spikes
        item.effect = mg.GameItemEffect.Kill
      else
        ? " UKNOWN GAME ITEM!!"
      end if
    end function

  end class
end namespace
