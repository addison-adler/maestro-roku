import "pkg:/source/core/Utils.bs"

namespace mg
  @node("MapManager", "Group")
  class MapManager
    mapSize = [0, 0]
    private platforms = []
    private levelGroup as mc.types.node
    private screenTileWidth = 128
    private screenTileHeight = 128
    private platformsByRow = []
    private collectablesByRow = []
    function new()
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function loadMap(levelGroup as mc.types.node, file as string)
      m.levelGroup = levelGroup
      text = readAsciiFile(file)
      json = text = invalid ? invalid : parseJson(text)
      m.parseTMXandCreatePlatforms(json)
    end function

    function getFloor(target as mc.types.node)
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      targetTranslation = target.translation
      targetTranslation = [targetTranslation[0] + feetTranslation[0], targetTranslation[1] + feetTranslation[1]]

      currentRow = int(targetTranslation[1] / m.screenTileHeight)

      ' Check for collision in the current row and possibly the row below.
      ' Adjust the range (e.g., -1 to 1) if the character can fall through more than one row per frame.
      for rowIndex = currentRow to currentRow + 1
        if rowIndex < m.platformsByRow.count() and rowIndex >= 0
          for each platform in m.platformsByRow[rowIndex]
            collisionType = platform@.getFloorCollision(feetCollider)
            if collisionType = mg.FloorCollision.OnFloor
              return platform
            end if
          end for
        end if
      end for

      return invalid
    end function

    function collectItems(target as mc.types.node)
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      targetTranslation = target.translation
      targetTranslation = [targetTranslation[0] + feetTranslation[0], targetTranslation[1] + feetTranslation[1]]

      currentRow = int(targetTranslation[1] / m.screenTileHeight)
      currentCol = int(targetTranslation[0] / m.screenTileWidth)

      ' Check for collision in the current row and possibly the row below.
      ' Adjust the range (e.g., -1 to 1) if the character can fall through more than one row per frame.
      for rowIndex = currentRow - 1 to currentRow
        if rowIndex < m.collectablesByRow.count() and rowIndex >= 0
          for each item in m.collectablesByRow[rowIndex]
            if not item.isCollected and item.startIndex = currentCol
              if item.effect = "kill"
                target@.onHit(item)
              else
                item.visible = false
                item.isCollected = true
              end if
            end if
          end for
        end if
      end for

      return invalid
    end function



    function getSideCollision(target as object, direction as integer) as object
      feetCollider = target.feetCollider
      feetTranslation = feetCollider.translation
      characterTranslation = target.translation
      characterPosition = [characterTranslation[0] + feetTranslation[0], characterTranslation[1] + feetTranslation[1]]

      currentRow = Int(characterPosition[1] / m.screenTileHeight)
      searchRows = [currentRow] ' Consider current row for lateral collision

      for each rowIndex in searchRows
        if rowIndex < m.platformsByRow.count() and rowIndex >= 0
          for each platform in m.platformsByRow[rowIndex]
            platformTranslation = platform.translation
            platformLeft = platformTranslation[0]
            platformRight = platformTranslation[0] + platform.width
            characterLeft = characterPosition[0]
            characterRight = characterPosition[0] + feetCollider.width

            ' Moving right and approaching the left boundary of a platform
            if direction = 1 and characterRight > platformLeft and characterLeft < platformRight
              ' Allow passing through if moving outwards from within a platform
              if characterLeft < platformLeft
                return platform ' Collision on the right
              end if

              ' Moving left and approaching the right boundary of a platform
            else if direction = -1 and characterLeft < platformRight and characterRight > platformLeft
              ' Allow passing through if moving outwards from within a platform
              if characterRight > platformRight
                return platform ' Collision on the left
              end if
            end if
          end for
        end if
      end for

      return invalid ' No collision detected, allowing free movement
    end function


    function resetLevel()
      for each row in m.collectablesByRow
        for each item in row
          item.visible = true
          item.isCollected = false
        end for
      end for
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ' Define a function to parse TMX JSON and create platforms
    private function parseTMXandCreatePlatforms(tmxData as mc.types.assocarray)
      ' Loop through each layer (assuming single layer for simplicity)
      for each layer in tmxData.layers
        ' Assuming a single layer for simplicity, process its data
        rowData = layer.data
        rowLength = tmxData.width
        numberOfRows = tmxData.height
        m.mapSize = [tmxData.width * m.screenTileWidth, tmxData.height * m.screenTileHeight]

        ' Process each row
        for rowIndex = 0 to numberOfRows - 1
          rowStartIndex = rowIndex * rowLength
          rowEndIndex = (rowIndex + 1) * rowLength - 1
          startIndex = -1
          length = 0

          ' Process each tile in the row
          for tileIndex = rowStartIndex to rowEndIndex
            tileValue = rowData[tileIndex]

            ' Check if tile is not empty and start index is not set
            if tileValue <> 0 and startIndex = -1
              if tileValue = 23
                m.createCoin(rowIndex, tileIndex - rowStartIndex, "coin" + str(tileIndex))
                startIndex = -1
              else if tileValue = 24
                ? "BAD GUY"
                m.createBadGuy(rowIndex, tileIndex - rowStartIndex, "badGuy" + str(tileIndex))
                startIndex = -1
              else if tileValue > 0 and tileValue < 20 and tileValue <> 5 and tileValue <> tileValue <> 9 and tileValue <> 4
                startIndex = tileIndex - rowStartIndex
              end if
              length = 1
            else if tileValue <> 0
              length += 1
            else if length > 0 and startIndex > -1
              ' Create a platform for the sequence of non-zero tiles
              m.createPlatform(rowIndex, startIndex, length, "platform" + str(startIndex))
              startIndex = -1
              length = 0
            end if
          next

          ' Check if the row ends with a platform
          if length > 0 and startIndex > -1

            m.createPlatform(rowIndex, startIndex, length, "platform" + str(startIndex))
          end if
        next
      next
    end function

    private function createPlatform(rowIndex as integer, startIndex as integer, length as integer, id as string)
      yPos = rowIndex * m.screenTileHeight
      platform = mc.createSGNode({
        "_type": "Floor"
        "id": id
        translation: [startIndex * m.screenTileWidth, yPos]
        size: [length * m.screenTileWidth, m.screenTileHeight]
        startIndex: startIndex
        length: length
        rowIndex: rowIndex
        color: "#5A24B6"
      }, m.levelGroup)
      rows = m.platformsByRow[rowIndex]
      if rows = invalid
        rows = []
        m.platformsByRow.push(rows)
      end if
      rows.push(platform)
      return platform
    end function

    private function createCoin(rowIndex as integer, startIndex as integer, id as string)
      yPos = rowIndex * m.screenTileHeight
      item = mc.createSGNode({
        "_type": "Collectable"
        "id": id
        translation: [startIndex * m.screenTileWidth, yPos]
        size: [m.screenTileWidth, m.screenTileHeight]
        startIndex: startIndex
        length: 1
        uri: "pkg:/images/sprites/coin-tile.png"
        effect: "coin"
        rowIndex: rowIndex
      }, m.levelGroup)
      rows = m.collectablesByRow[rowIndex]
      if rows = invalid
        rows = []
        m.collectablesByRow.push(rows)
      end if
      rows.push(item)
      return item
    end function

    private function createBadGuy(rowIndex as integer, startIndex as integer, id as string)
      yPos = rowIndex * m.screenTileHeight
      item = mc.createSGNode({
        "_type": "Collectable"
        "id": id
        uri: "pkg:/images/sprites/bad-guy.png"
        translation: [startIndex * m.screenTileWidth, yPos]
        size: [m.screenTileWidth, m.screenTileHeight]
        startIndex: startIndex
        length: 1
        effect: "kill"
        rowIndex: rowIndex
      }, m.levelGroup)
      rows = m.collectablesByRow[rowIndex]
      if rows = invalid
        rows = []
        m.collectablesByRow.push(rows)
      end if
      rows.push(item)
      return item
    end function


  end class
end namespace
