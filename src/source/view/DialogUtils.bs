import "pkg:/components/view/mixin/FocusMixin.bs"
import "pkg:/source/core/BaseClass.bs"
import "pkg:/source/core/Date.bs"
import "pkg:/source/view/Animation.bs"
import "pkg:/source/core/MIOC.bs"

namespace mv
  ' utility for creating various dialogs. Only works with brighterscript classes, and only allows for one dialog at a time
  interface IDialogText
    optional title as string
    optional message as string
    optional buttonTitles as string[]
  end interface
  class DialogUtil extends mc.BaseClass

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Fields
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    public dialog

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Fields
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private delegate
    private channelStore
    private callback
    private dialogContainer as roSGNode
    private text as mv.IDialogText

    @inject("styleManager")
    private styleManager as roSGNode

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Initialization
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function new(delegate as dynamic)
      super("DialogUtil")
      ' bundle = m.styleManager@.loadBundle("pkg:/source/lib/DialogUtil.bundle")
      bundle = {
        text: {
          onDialogButtonSelected: {
            continue: "Continue"
            clear: "Clear"
            back: "Back"
          }
        }
      }
      m.text = bundle.text
      m.delegate = delegate
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Public Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    function showDialog(title as string, message as string, buttonTitles = m.text.buttonTitles as roArray, callback = invalid as function, additionalArgs = {} as roAssociativeArray) as roSGNode
      if additionalArgs = invalid
        additionalArgs = {}
      end if
      container = m.getDialogContainer()
      dialog = m.createSGNode("Dialog", container, `dialog_${container.getChildCount()}`, [
        {
          title: title
          message: message
          buttons: buttonTitles
      }, additionalArgs])
      m.showDialogScreen(dialog, callback)
      return dialog
    end function

    function showDialogFromJson(json as IDialogText, callback = invalid as function, additionalArgs = {} as roAssociativeArray) as roSGNode
      if additionalArgs = invalid
        additionalArgs = {}
      end if
      container = m.getDialogContainer()
      dialog = m.createSGNode("Dialog", container, `dialog_${container.getChildCount()}`, [
        {
          title: json.title
          message: json.message
          buttons: json.buttonTitles
      }, additionalArgs])
      m.showDialogScreen(dialog, callback)
      return dialog
    end function

    'show any screen as a dialog. Must have a buttonSelected: integer field
    function showDialogScreen(dialog as roSGNode, callback = invalid as function, lockFocus = true as boolean) as roSGNode
      container = m.getDialogContainer()
      if not container.getParent().isSameNode(dialog.getParent())
        m.log.info("this dialog is not in the dialog containers, adding it now")
        container.appendChild(dialog)
      end if
      mc.setOrAddNodeField(dialog, "dialogLocksFocus", lockFocus)
      m.observeNodeField(dialog, "buttonSelected", m.onDialogDismiss, "both", true)
      if callback <> invalid
        m.log.info("delegate is observing this dialog")
        m.delegate.observeNodeField(dialog, "buttonSelected", callback, "both", true)
      end if
      'FIXME(gcook): need to add a new feature to maestro's focus manager to allow it to set focus on child of focus-locked view : https://github.com/georgejecook/maestro-roku/issues/108
      if lockFocus
        m.setFocusLocked(dialog, "focused on new dialog")
      else
        m.setFocusUnlocked("this dialog does not lock focus")
        m.setFocus(dialog)
      end if
      return dialog
    end function

    function dismissDialog(dialog as roSGNode)
      if dialog <> invalid
        (dialog as dynamic).buttonSelected = -1
      end if
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Private Methods
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Dialog Callbacks
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function ondDialogButtonSelected(selectedButton as integer, dialog as IDialogScreen)
      selectedButtonText = dialog.buttons[selectedButton]
      m.log.info("keyboard button selected: ", selectedButtonText, ", text ", dialog.text)
      isClosing = false


      '????
      'FIXME - CHECK THIS WITH DACI
      buttons = (m.text as dynamic).onKeyboardDialogButtonSelected as dynamic

      if selectedButtonText = buttons.password
        (dialog.textEditBox as dynamic).secureMode = not (dialog.textEditBox as dynamic).secureMode
      else if selectedButtonText = buttons.continue
        isClosing = true
        m.delegate.__cb = m.callback
        'bs:disable-next-line
        m.delegate.__cb(dialog.text)
      else if selectedButtonText = buttons.back
        isClosing = true
      else if selectedButtonText = buttons.clear
        dialog.text = ""
      end if

      if isClosing
        m.closeDialog()
      end if
    end function

    private function closeDialog()
      m.log.method("closeDialog")

      if m.dialog <> invalid and m.dialog.close = false
        m.dialog.close = true
        (mc.getScene() as dynamic).dialog = invalid
      end if

      m.dialog = invalid
    end function

    private function getDialogContainer() as roSGNode
      scene = mc.getScene()
      container = scene.findNode("_dialogContainer")

      if container = invalid
        container = m.createSGNode("Group", scene, "_dialogContainer")
      end if
      return container
    end function

    private function setFocus(control as roSGNode)
      'bs:disable-next-line
      mv.setFocus(control)
    end function

    protected function setFocusLocked(control as roSGNode, reason as string)
      'bs:disable-next-line
      mv.setFocusLocked(control, reason)
    end function

    protected function setFocusUnlocked(reason = "" as string)
      'bs:disable-next-line
      mv.setFocusUnlocked(reason)
    end function

    protected function setFocusOnApp()
      m.log.info("all dialogs dismissed, setting focus on the app")

      m.setFocus(mioc.getInstance("appController"))
    end function

    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    '++ Callbacks
    '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    private function onDialogDismiss(selectedIndex as integer, dialog as roSGNode)
      m.log.info("onDialogDismiss", selectedIndex, mc.dv(dialog))
      'future enhancement - bare in mind that we could have out of order dialogs in future
      dialogContainer = m.getDialogContainer()
      dialogContainer.removeChild(dialog)
      numDialogs = dialogContainer.getChildCount()

      if numDialogs > 0
        m.log.info("there are more dialogs in the dialog stack")
        dialog = dialogContainer.getChild(numDialogs - 1)
        if dialog.dialogLocksFocus
          m.log.info("this dialog locks focus: locking on it now")
          m.setFocusLocked(dialog, "another dialog is still present")
        else
          m.setFocusUnlocked("this dialog does not lock focus")
          m.setFocus(dialog)
        end if
      else
        m.log.info("there are no more dialog. removing dialog stack")
        m.setFocusUnlocked("all dialogs dismissed")
        m.setFocusOnApp()
        mc.getScene().removeChild(dialogContainer)
      end if
    end function
  end class
end namespace
